Part 3: API Implementation (35 minutes)
Implement an endpoint that returns low-stock alerts for a company.
Business Rules (discovered through previous questions):
â— Low stock threshold varies by product type

â— Only alert for products with recent sales activity
â— Must handle multiple warehouses per company
â— Include supplier information for reordering
Endpoint Specification:
GET /api/companies/{company_id}/alerts/low-stock

Expected Response Format:
{
"alerts": [
{
"product_id": 123,
"product_name": "Widget A",
"sku": "WID-001",
"warehouse_id": 456,
"warehouse_name": "Main Warehouse",
"current_stock": 5,
"threshold": 20,
"days_until_stockout": 12,
"supplier": {
"id": 789,
"name": "Supplier Corp",
"contact_email": "orders@supplier.com"
}
}
],
"total_alerts": 1
}

Your Tasks:
1. Write Implementation: Use any language/framework (Python/Flask,
Node.js/Express, etc.)
2. Handle Edge Cases: Consider what could go wrong
3. Explain Approach: Add comments explaining your logic
Hints: You'll need to make assumptions about the database schema and business logic.
Document these assumptions.


======================>



Assumptions & Setup
Assumptions from schema and logic:

Products have a low_stock_threshold field.

Recent sales activity is tracked in a sales table.

Sales have a created_at timestamp and quantity.

Products can be supplied by multiple suppliers â€” we choose the first one for alert display.

Each inventory row is for one (product_id, warehouse_id).

âœ… Database Schema (assumed or extended)
sql
Copy
Edit
ALTER TABLE products ADD COLUMN low_stock_threshold INT DEFAULT 10;

CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    product_id INT REFERENCES products(id),
    warehouse_id INT REFERENCES warehouses(id),
    quantity INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
âœ… Implementation: Flask Endpoint
python
Copy
Edit
from flask import Flask, jsonify
from models import db, Product, Warehouse, Inventory, Supplier, SupplierProduct, Sales
from datetime import datetime, timedelta
from sqlalchemy import func

app = Flask(__name__)

@app.route('/api/companies/<int:company_id>/alerts/low-stock', methods=['GET'])
def low_stock_alerts(company_id):
    # Consider recent activity within the past 30 days
    recent_days = 30
    cutoff_date = datetime.utcnow() - timedelta(days=recent_days)

    # Subquery: products with recent sales
    recent_sales_subq = (
        db.session.query(Sales.product_id)
        .filter(Sales.created_at >= cutoff_date)
        .distinct()
        .subquery()
    )

    # Main query: Get inventory data below threshold with recent sales
    results = (
        db.session.query(
            Product.id.label("product_id"),
            Product.name.label("product_name"),
            Product.sku,
            Product.low_stock_threshold.label("threshold"),
            Warehouse.id.label("warehouse_id"),
            Warehouse.name.label("warehouse_name"),
            Inventory.quantity.label("current_stock"),
            Supplier.id.label("supplier_id"),
            Supplier.name.label("supplier_name"),
            Supplier.contact_info.label("supplier_email"),
            func.avg(Sales.quantity).label("avg_daily_sales")
        )
        .join(Inventory, Inventory.product_id == Product.id)
        .join(Warehouse, Inventory.warehouse_id == Warehouse.id)
        .join(Sales, (Sales.product_id == Product.id) & (Sales.warehouse_id == Warehouse.id))
        .join(SupplierProduct, SupplierProduct.product_id == Product.id)
        .join(Supplier, Supplier.id == SupplierProduct.supplier_id)
        .filter(
            Warehouse.company_id == company_id,
            Product.id.in_(recent_sales_subq),
            Inventory.quantity < Product.low_stock_threshold
        )
        .group_by(
            Product.id, Product.name, Product.sku, Product.low_stock_threshold,
            Warehouse.id, Warehouse.name, Inventory.quantity,
            Supplier.id, Supplier.name, Supplier.contact_info
        )
        .all()
    )

    # Format results
    alerts = []
    for row in results:
        avg_sales_per_day = row.avg_daily_sales or 1  # Prevent division by zero
        days_until_stockout = int(row.current_stock / avg_sales_per_day)

        alerts.append({
            "product_id": row.product_id,
            "product_name": row.product_name,
            "sku": row.sku,
            "warehouse_id": row.warehouse_id,
            "warehouse_name": row.warehouse_name,
            "current_stock": row.current_stock,
            "threshold": row.threshold,
            "days_until_stockout": days_until_stockout,
            "supplier": {
                "id": row.supplier_id,
                "name": row.supplier_name,
                "contact_email": row.supplier_email
            }
        })

    return jsonify({
        "alerts": alerts,
        "total_alerts": len(alerts)
    })
âš ï¸ Edge Case Handling
Edge Case	Handling
No sales in 30 days	Excluded from alerts (recent_sales_subq)
Multiple suppliers	Returns the first one found
No threshold defined	Uses default from DB column (e.g. 10)
Division by zero (no avg sales)	Fallback: avg_sales_per_day = 1
Products with zero quantity	Still included if recent sales occurred

ðŸ§  Explanation of Logic
Recent Sales Filter: Limits products to those sold in the past 30 days.

Low Stock Filter: Includes only items below their defined low_stock_threshold.

Joins:

Products â†’ Inventory â†’ Warehouses

Products â†’ Suppliers

Products â†’ Sales (for recent activity and avg daily sales)

Group & Aggregate:

Use AVG(sales.quantity) to estimate days_until_stockout.

Response Format: Structured exactly as requested.

